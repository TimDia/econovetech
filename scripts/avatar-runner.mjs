import fs from 'fs';
import path from 'path';
import crypto from 'crypto';

const root = process.cwd();
const avatarsDir = path.join(root, 'avatars');
const marketDir  = path.join(root, 'marketplace');
const reportsDir = path.join(root, 'reports');

function ensureDirs() {
  for (const d of [avatarsDir, marketDir, reportsDir]) {
    if (!fs.existsSync(d)) fs.mkdirSync(d, { recursive: true });
  }
}

function listAvatarJobs(limit = 1000) {
  const files = fs.readdirSync(avatarsDir).filter(f => f.endsWith('.json'));
  return files.slice(0, limit).map(f => path.join(avatarsDir, f));
}

function makeAssetContent(i) {
  const now = new Date().toISOString();
  const id = crypto.randomBytes(8).toString('hex');
  return {
    id,
    title: UEOS Asset #,
    createdAt: now,
    description: "Autogenerated placeholder asset for Econovetech marketplace.",
    attributes: {
      rarity: ["common","uncommon","rare","epic","legendary"][Math.floor(Math.random()*5)],
      power: Math.floor(Math.random()*100),
      creator: "UEOS Avatar Worker"
    }
  };
}

function main() {
  ensureDirs();
  const jobs = listAvatarJobs(); // process all existing jobs in /avatars
  let created = 0;

  for (const jobPath of jobs) {
    try {
      const job = JSON.parse(fs.readFileSync(jobPath, 'utf8'));
      const idx = job.id ?? created + 1;
      const asset = makeAssetContent(idx);

      const outFile = path.join(marketDir, sset_.json);
      fs.writeFileSync(outFile, JSON.stringify(asset, null, 2), 'utf8');

      const repFile = path.join(reportsDir, eport_.txt);
      fs.writeFileSync(repFile,
        \Asset: \\nID: \\nRarity: \\nPower: \\nGenerated:\\n\,
        'utf8'
      );

      // update job status
      job.status = "completed";
      job.asset = path.basename(outFile);
      fs.writeFileSync(jobPath, JSON.stringify(job, null, 2), 'utf8');

      created++;
    } catch (e) {
      console.error("Failed job:", jobPath, e);
    }
  }

  console.log(\✅ Created \ assets → ./marketplace and reports → ./reports\);
}

main();
